# 汇编语言

## 结构语句结构与框架

**采用分段结构**：将远程许的指令代码，数据变量，数据分别定义在不同的主存段中，典型的，一个源程序包括三个段：**代码段**，数据段，堆栈段。

注意：一个源程序中可包含的段数是不受限制的，但是8086CPU只提供了4个段寄存器，所以在一个源程序中最多只能操作4个段,如果想要操作更多个段的话，需要将现有的某个段存入某个段寄存器，然后切换到新的段，再将原来的段寄存器中的内容恢复。

### 语义结构

**语义结构**：语义结构是汇编语言程序的结构，它由**数据段**，**代码段**，**堆栈段**组成。

`[名字项] 操作项 [操作数项] [;注释项]`

其中[]表示可选项

作用分为三类：**伪指令语句**，**指令语句**，**宏指令语句**

1. **伪指令语句**：说明程序运行的处理器平台，进行段定义，变量与常量定义，过程定义，宏定义一级源程序的开始与结束定义。
    伪指令语句作用于汇编过程，用来指示汇编程如何进行源程序汇编。不是实现操作的。
2. **指令语句**：包括一条汇编语言指令。程序的操作功能是由指令语句来实现的
3. **宏指令语句**：宏指令是允许程序员自定义的一种特殊形式的指令。宏指令语句用来描述宏指令的使用

4. 名字项：是一个符合特定规则的字符长，其最大长度不能超过31个字符，规定为：
    - 26个英文字母(不分大小写)，数字符，以及?,_,@,$等，不能以数字开头
    - 数字不能作为名字项的第一个字符。
    - .只能作为名字项第一个字符使用。
5. 操作项：操作项是一条语句中必不可少的部分。

6. 操作数项：可以是一个，两个或者没有，可以是**常量**，**变量**，**寄存器**，**指令标号**，**过程名**，**段名**或者**表达式**

# 框架：

```assembly
include io32.inc
   .data ; 数据段，用来存放数据
   ;.....  存放数据
   .code ;代码段，用来写代码
start:		; 程序执行的起始位置
	; ...... 写代码
	exit 0		; 程序正常执行结束
	end start	; 汇编结束
```

注意：程序执行结束并不代表汇编结束



# 输入输出的子程序

## 输入子程序

|  子程序名   |           功能说明           |
| :---------: | :--------------------------: |
| **READMSG** | **输入一个字符串，回车结束** |
|  **READC**  |    **输入一个字符，回显**    |

## 输出子程序

|  子程序名   |        功能说明         |
| :---------: | :---------------------: |
| **DISPMSG** | **显示字符串，以0结尾** |
|  **DISPC**  |    **显示一个字符**     |



## 常用的伪指令

### 1. 段定义伪指令

格式：

```assembly
段名 SEGMENT [定位类型] [组合类型] [‘类别’]
    ...... ; 段的具体内容
段名 ENDS
```

- 定位类型：PARA BYTE WORD DWORD PAGE --> 对段首地址进行要求
  - `PARA`：段长为2字节，段首地址为偶数
  - `BYTE`：段长为1字节，段首地址为任意值
  - `WORD`：段长为2字节，段首地址为偶数
  - `DWORD`：段长为4字节，段首地址可以被4整除
  - `PAGE`：段长为页长，段首地址可以被256整除
- 组合类型：PUBLIC STACK COMMON
  - `PUBLIC`：段中定义的变量、常量、过程等在其他段中也可以访问
  - `STACK`：段中定义的变量、常量、过程等用于堆栈操作
  - `COMMON`：段中定义的变量、常量、过程等在多个段中共享
- 类别：任意一个合法的字符串，起到组合作用

### 2. ASSUME伪指令

ASSUME是建立段寄存器与段之间联系的语句，是必不可少的，格式为：

```assembly
ASSUME 段寄存器名:段名 [,段寄存器名:段名,[,...]]
```

### 3. 源程序结束伪指令

源程序结束伪指令格式：

```assembly
END [段名]
```

# 数据处理

## 数据表示

### 1. 常数

以后缀的形式表达十进制，十六进制和二进制。如果在表达十六进制的时候，字母开头的话，则需添加一个0来表示16进制

|   进制   |       举例        |
| :------: | :---------------: |
|  十进制  |     100，255D     |
| 十六进制 | 64H，0FFH，0B800H |
|  二进制  |     01101100B     |

### 2. 字符和字符串

使用单引号或双引号来包括字符/字符串，其数值时每个字符对应的ASCII码值，例如'd' ( = 64H),'AB',"Hello,Assembly!".

在字符串中有单引号时，则使用双引号括字符串，如："Let's go",反之亦然

也可以直接使用单引号或双引号的值代表双引号/单引号，单引号：27H，双引号：22H

### 3.符号常量(相当于高级语言中的常量)

方式一：使用EQU来定义符号名，格式：

```assembly
; 符号名 EQU 数值表达式
i EQU a+b
; 符号名 EQU <字符串>
string EQU <hello assembly!>
```

方式二：使用=等号位指令，格式：

```assembly
;符号名 = 数值表达式
string = 'hello assembly!'
```

注意：EQU用于数值等价时不能重复定义符号名，即定义之后不能更改，但是=允许有重复值，如：

```assembly
STD_INPUT_HANDLE = -10
STD_OUTPUT_HANDLE = -11
COUNT = 100
COUNT = COUNT + 64H
```

### 数值表达式：

定义：用运算符连接各种常量所构成的算式

算术运算符：+ - * /



## 变量

-   说明：程序运行中随之发生变化的结果，保存在可读可写的主存空间

-   实质：主存单元的数据，因而可以改变。
-   说明：
    -   变量需要实现定义才能使用
    -   变量具有属性，方便应用。
    -   变量表达主存数据，即存储器操作数
    -   相当于高级语言中的一维数组

### 定义：

申请存储空间，还可以进行存储单元初始化：

```assembly
;变量名，变量定义为指令，初值表

```

变量名是用户标识符，表示手元素逻辑地址

-   变量定义的伪指令有：
    -   BYTE(8位字节),WORD(16),DWORD(64),FWORD,QWORD,TBYTE
-   初值表：使用逗号分隔的参数
    -   各种形式的常量
    -   使用？表示处置不清定，即未赋初值
    -   复制操作符DUP：
    -   重复次数 DUP (重复参数)

#### 字节数据

在定义字符串时，只需要使用BYTE即可

#### 字量数据

说明：WORD定义16位，字量变量数据

-   可以表达：
    -   16位无符号和有符号整数
    -   16位段选择器，16位偏移地址

#### 双字量数据

-   DWORD定义32位，双字量变量数据
-   可以表达：
    -   32位无符号和有符号整数
    -   32位偏移地址，线性地址或段基地址
-   32位数据包含4个字节，以“高对高，低对低”原则占用4个连续字节空间

### 变量定位

-   变量定义的存储空间，按照书写的先后顺序一个接着一个分配
    -   ORG 参数：控制存放的便宜地址，如：`org 100h ;从偏移地址100H处安排变量`
-   指令代码也有汇编程序按照语句的书写顺序安排存储空间
-   定位伪指令也可以用于控制代码的偏移地址
