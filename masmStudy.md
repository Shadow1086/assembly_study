# 汇编语言学习笔记

## 一、基础概念

### 1.1 汇编语言结构

**采用分段结构**：将远程许的指令代码，数据变量，数据分别定义在不同的主存段中，典型的，一个源程序包括三个段：**代码段**，数据段，堆栈段。

注意：一个源程序中可包含的段数是不受限制的，但是8086CPU只提供了4个段寄存器，所以在一个源程序中最多只能操作4个段,如果想要操作更多个段的话，需要将现有的某个段存入某个段寄存器，然后切换到新的段，再将原来的段寄存器中的内容恢复。

### 1.2 程序框架

```assembly
include io32.inc
   .data ; 数据段，用来存放数据
   ;.....  存放数据
   .code ;代码段，用来写代码
start:		; 程序执行的起始位置
	; ...... 写代码
	exit 0		; 程序正常执行结束
	end start	; 汇编结束
```

注意：程序执行结束并不代表汇编结束

---

## 二、语法结构

### 2.1 语义结构

**语义结构**：语义结构是汇编语言程序的结构，它由**数据段**，**代码段**，**堆栈段**组成。

代码段：

-   段基地址：代码段寄存器CS指示
-   偏移地址：指令指针寄存器EIP保存

数据段：

-   段基地址：数据段寄存器DS指示
-   偏移地址：各种存储器寻址方式计算出来的

堆栈段

-   段基地址：堆栈段寄存器SS指示
-   偏移地址：堆栈指针寄存器ESP保存



`[名字项] 操作项 [操作数项] [;注释项]`

其中[]表示可选项

作用分为三类：**伪指令语句**，**指令语句**，**宏指令语句**

1. **伪指令语句**：说明程序运行的处理器平台，进行段定义，变量与常量定义，过程定义，宏定义一级源程序的开始与结束定义。
    伪指令语句作用于汇编过程，用来指示汇编程如何进行源程序汇编。不是实现操作的。
2. **指令语句**：包括一条汇编语言指令。程序的操作功能是由指令语句来实现的
3. **宏指令语句**：宏指令是允许程序员自定义的一种特殊形式的指令。宏指令语句用来描述宏指令的使用

4. 名字项：是一个符合特定规则的字符长，其最大长度不能超过31个字符，规定为：
    - 26个英文字母(不分大小写)，数字符，以及?,_,@,$等，不能以数字开头
    - 数字不能作为名字项的第一个字符。
    - .只能作为名字项第一个字符使用。
5. 操作项：操作项是一条语句中必不可少的部分。

6. 操作数项：可以是一个，两个或者没有，可以是**常量**，**变量**，**寄存器**，**指令标号**，**过程名**，**段名**或者**表达式**

### 2.2 常用伪指令

#### 2.2.1 段定义伪指令

格式：

```assembly
段名 SEGMENT [定位类型] [组合类型] ['类别']
    ...... ; 段的具体内容
段名 ENDS
```

- 定位类型：PARA BYTE WORD DWORD PAGE --> 对段首地址进行要求
  - `PARA`：段长为2字节，段首地址为偶数
  - `BYTE`：段长为1字节，段首地址为任意值
  - `WORD`：段长为2字节，段首地址为偶数
  - `DWORD`：段长为4字节，段首地址可以被4整除
  - `PAGE`：段长为页长，段首地址可以被256整除
- 组合类型：PUBLIC STACK COMMON
  - `PUBLIC`：段中定义的变量、常量、过程等在其他段中也可以访问
  - `STACK`：段中定义的变量、常量、过程等用于堆栈操作
  - `COMMON`：段中定义的变量、常量、过程等在多个段中共享
- 类别：任意一个合法的字符串，起到组合作用

#### 2.2.2 ASSUME伪指令

ASSUME是建立段寄存器与段之间联系的语句，是必不可少的，格式为：

```assembly
ASSUME 段寄存器名:段名 [,段寄存器名:段名,[,...]]
```

#### 2.2.3 源程序结束伪指令

源程序结束伪指令格式：

```assembly
END [段名]
```

---

# 系统组成

寄存器：

-   通用寄存器：ax,bx,cx,dx;sp,bp,si,di
-   8086:段寄存器：四个：cs,ds,ss,es(依次为：代码段寄存器，数据段寄存器，堆栈段寄存器，附加段寄存器)，存放地址，

逻辑地址：

逻辑地址 = 段基地址：偏移地址

其中段基地址位在贮存中的起始地址，偏移地址是距离段基地址的位移量

逻辑地址和物理地址的转换：



## 三、数据处理

### 3.1 数据表示

#### 3.1.1 常数

以后缀的形式表达十进制，十六进制和二进制。如果在表达十六进制的时候，字母开头的话，则需添加一个0来表示16进制

|   进制   |       举例        |
| :------: | :---------------: |
|  十进制  |     100，255D     |
| 十六进制 | 64H，0FFH，0B800H |
|  二进制  |     01101100B     |

#### 3.1.2 字符和字符串

使用单引号或双引号来包括字符/字符串，其数值时每个字符对应的ASCII码值，例如'd' ( = 64H),'AB',"Hello,Assembly!".

在字符串中有单引号时，则使用双引号括字符串，如："Let's go",反之亦然

也可以直接使用单引号或双引号的值代表双引号/单引号，单引号：27H，双引号：22H

#### 3.1.3 符号常量(相当于高级语言中的常量)

方式一：使用EQU来定义符号名，格式：

```assembly
; 符号名 EQU 数值表达式
i EQU a+b
; 符号名 EQU <字符串>
string EQU <hello assembly!>
```

方式二：使用=等号位指令，格式：

```assembly
;符号名 = 数值表达式
string = 'hello assembly!'
```

注意：EQU用于数值等价时不能重复定义符号名，即定义之后不能更改，但是=允许有重复值，如：

```assembly
STD_INPUT_HANDLE = -10
STD_OUTPUT_HANDLE = -11
COUNT = 100
COUNT = COUNT + 64H
```

#### 3.1.4 数值表达式

定义：用运算符连接各种常量所构成的算式

算术运算符：+ - * /

### 3.2 变量

-   说明：程序运行中随之发生变化的结果，保存在可读可写的主存空间

-   实质：主存单元的数据，因而可以改变。
-   说明：
    -   变量需要实现定义才能使用
    -   变量具有属性，方便应用。
    -   变量表达主存数据，即存储器操作数
    -   相当于高级语言中的一维数组

#### 3.2.1 变量定义

申请存储空间，还可以进行存储单元初始化：

```assembly
;变量名，变量定义为指令，初值表

```

变量名是用户标识符，表示手元素逻辑地址

-   变量定义的伪指令有：
    -   BYTE(8位字节),WORD(16),DWORD(64),FWORD,QWORD,TBYTE
-   初值表：使用逗号分隔的参数
    -   各种形式的常量
    -   使用？表示处置不清定，即未赋初值
    -   复制操作符DUP：
    -   重复次数 DUP (重复参数)

##### 字节数据

在定义字符串时，只需要使用BYTE即可

##### 字量数据

说明：WORD定义16位，字量变量数据

-   可以表达：
    -   16位无符号和有符号整数
    -   16位段选择器，16位偏移地址

##### 双字量数据

-   DWORD定义32位，双字量变量数据
-   可以表达：
    -   32位无符号和有符号整数
    -   32位偏移地址，线性地址或段基地址
-   32位数据包含4个字节，以"高对高，低对低"原则占用4个连续字节空间

#### 3.2.2 变量定位

-   变量定义的存储空间，按照书写的先后顺序一个接着一个分配
    -   ORG 参数：控制存放的便宜地址，如：`org 100h ;从偏移地址100H处安排变量`
-   指令代码也有汇编程序按照语句的书写顺序安排存储空间
-   定位伪指令也可以用于控制代码的偏移地址

#### 3.2.3 变量属性

-    变量定义
    -   分配存储空间
    -   赋初值
    -   创建变量名
-   变量名具有两类属性：
    1.  地址属性：首个变量所在存储单元的逻辑地址，包含了段基地址和偏移地址
    2.  类型属性：变量定义的数据单位

##### 地址操作符

-   用于获取变量名的地址属性：

|  地址操作符   |               作用               |
| :-----------: | :------------------------------: |
|      [ ]      | 括起来的表达式作为存储器地址指针 |
|       $       |         返回当前偏移地址         |
| OFFSET 变量名 |    返回变量名所在段的偏移地址    |
|  SEG 变量名   |   返回段基地址(实地址存储模型)   |

##### 类型操作符

-   类型操作符使用变量名的类型属性

|    类型操作符     |                    功能                    |
| :---------------: | :----------------------------------------: |
| 类型名 PTR 变量名 | 将变量名按照指定的类型使用（强制类型转换） |
|    TYPE 变量名    |         返回占用字节空间的字量数值         |
|  LENGTHOF 变量名  |           返回整个变量的数据项数           |
|   SIZEOF 变量名   |          返回整个变量占用的字节数          |

#### 3.2.4 变量类型属性程序

-   `ptr`:强制类型转换
-   `type`：用来返回类型值，如：byte返回1,word返回2，dword返回4，即返回字节空间
-   `lengthof`：返回数组中的数据个数



---

## 四、指令集

### 4.1 数据传送类指令

分类：

-   通用传送指令
-   其他传送指令

数据传送：

-   把数据从一个位置传送到另一个位置

除了标志寄存器传送指令外，均不影响标志位

传送指令：MOV，交换指令：XCHG

#### 4.1.1 传送指令

不允许主存储器和主存储器直接相互传输数据，需要一个中间介质

注意：

-   双操作数必须类型一致
-   操作数必须有明确的类型
-   双操作数不允许都是存储单元
-   操作专用寄存器的指令有限



### 4.1.2 交换指令XCHG

-   将原操作数和目的操作数内容进行交换
    -   通用寄存器和通用寄存器之间
    -   通用寄存器和存储器之间
-   空操作指令：NOP: XCHG EAX,EAX
    -   处理器操作空操作该指令，需要花费时间，在主存中过也要占用一个字节空间
    -   实现短时间的延时
    -   临时占用代码空间

```assembly
xchg eax,ebx
xchg edx,var
xchg al,[edi]
```

## 寻址方式：

-   寄存器寻址：从寄存器取入寄存器,mov eax,ebx
-   立即数寻址：如：mov eax,00020001h;只用于原操作数，常用来给寄存器和存储单元复制，以常量形式直接表达
-   存储器寻址：操作数在主存中，通过存储器地址指示，
    -   直接寻址：使用变量名：mov ecx,count ; count是变量
    -   寄存器间接寻址，如：mov al,[esi];mov [esi],al
    -   寄存器相对寻址：如：mov al,num[esi];xchg al,tab[esi]；+号，在已有的间接寻址的基础上加上位移量
    -   变址寻址：如：mov edi,[ebx+esi];使用变址寄存器寻址操作数，有效地址 = 基址寄存器+变址寄存器

---

## 五、输入输出子程序

### 5.1 输入子程序

|  子程序名   |           功能说明           |
| :---------: | :--------------------------: |
| **READMSG** | **输入一个字符串，回车结束** |
|  **READC**  |    **输入一个字符，回显**    |

### 5.2 输出子程序

|  子程序名   |        功能说明         |
| :---------: | :---------------------: |
| **DISPMSG** | **显示字符串，以0结尾** |
|  **DISPC**  |    **显示一个字符**     |
